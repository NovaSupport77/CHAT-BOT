# -*- coding: utf-8 -*-
from pyrogram import Client, filters, enums
from pyrogram.types import InlineKeyboardMarkup, InlineKeyboardButton, Message
# The pyrogram.errors import is necessary for catching exceptions during broadcast
from pyrogram.errors import FloodWait, UserNotParticipant, ChatWriteForbidden, PeerIdInvalid, RPCError
import os, json, random, threading, asyncio, time
from http.server import BaseHTTPRequestHandler, HTTPServer
from datetime import datetime
import re # For advanced text processing

# -------- Keep-Alive Web Server for Render/Cloud Deployments --------
# THIS IS THE FIX FOR "No open ports detected" ERROR
class HealthCheckHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header('Content-type', 'text/html')
        self.end_headers()
        self.wfile.write(b"Bot is running and healthy!")

def keep_alive():
    # Use the port specified by the environment, default to 8080 if not set
    # Render requires a service to bind to a port to stay running.
    port = int(os.environ.get("PORT", 8080))
    try:
        server = HTTPServer(('0.0.0.0', port), HealthCheckHandler)
        print(f"Starting keep-alive server on port {port}")
        server.serve_forever()
    except Exception as e:
        print(f"Could not start health check server: {e}")

# Start the web server thread before starting the bot
threading.Thread(target=keep_alive, daemon=True).start()
# -------- END Keep-Alive Web Server --------

# -------- Env Vars --------
# NOTE: Set these environment variables before running!
# Owner ID is crucial for owner-only commands (stats, broadcast)
API_ID = int(os.environ.get("API_ID", "0"))
API_HASH = os.environ.get("API_HASH", "")
BOT_TOKEN = os.environ.get("BOT_TOKEN", "")

# Please ensure you set this to your actual Telegram User ID
OWNER_ID = int(os.environ.get("OWNER_ID", "7589623332"))

DEVELOPER_USERNAME = "Voren"
DEVELOPER_HANDLE = "@TheXVoren"
SUPPORT_CHAT = "https://t.me/Evara_Support_Chat"
UPDATES_CHANNEL = "https://t.me/Evara_Updates"

# -------- Bot Client --------
app = Client("advanced_chatbot", api_id=API_ID, api_hash=API_HASH, bot_token=BOT_TOKEN)

# -------- Global Vars --------
START_TIME = datetime.now()
CHATBOT_STATUS = {} # {chat_id: True/False}
TAGGING = {} # {chat_id: True/False}
# {user_id: {"reason": str, "chat_id": int, "username": str, "first_name": str, "time": float}}
AFK_USERS = {}

# New image URLs and text
START_PHOTO = "https://iili.io/KVzgS44.jpg"
PING_PHOTO = "https://iili.io/KVzbu4t.jpg"
DEVELOPER_PHOTO = "https://iili.io/KVzmgWl.jpg"

# ----------------- FANCY FONTS APPLIED HERE -----------------
INTRO_TEXT_TEMPLATE = (
    "ğ‡á´‡Ê {mention_name}\n"
    "âœ¦ ğˆ á´§á´ á´§É´ á´§á´…á´ á´€É´á´„á´‡á´… á´„Êœá´§á´› Ê™á´á´› á´¡Éªá´›Êœ sá´á´á´‡ Ò“á´‡á´€á´›á´œÊ€á´‡s. \n"
    "âœ¦ ğ‘á´‡á´˜ÊŸÊ ÉªÉ´ É¢Ê€á´á´œá´˜s & á´˜Ê€Éªá´ á´§á´›á´‡s ğŸ¥€\n"
    "âœ¦ ğá´ á´§Ê™á´œsÉªÉ´É¢ & á´¢á´‡Ê€á´ á´…á´á´¡É´á´›Éªá´á´‡\n"
    "âœ¦ ğ‚ÊŸÉªá´„á´‹ Êœá´‡ÊŸá´˜ Ê™á´œá´›á´›á´É´ Ò“á´Ê€ á´„á´á´á´á´§É´á´…s â¤ï¸\n"
    "â– ğŒá´§á´…á´‡ Ê™Ê...{developer}"
)

ABOUT_TEXT = (
    "â– ğ€ á´ÉªÉ´Éª á´„Êœá´§á´› Ê™á´á´› Ò“á´Ê€ á´›á´‡ÊŸá´‡É¢Ê€á´§á´s É¢Ê€á´á´œá´˜s & á´˜Ê€Éªá´ á´§á´›á´‡ á´á´‡ssá´§É¢á´‡s\n"
    "â— ğ–Ê€Éªá´›á´›á´‡É´ ÉªÉ´ á´˜Êá´›Êœá´É´ \n"
    "â— ğŠá´‡á´˜á´˜ Êá´á´œÊ€ É¢Ê€á´á´œá´˜ á´§á´„á´›Éªá´ á´‡.\n"
    "â— ğ€á´…á´… á´á´‡ É´á´á´¡ Ê™á´§Ê™Ê ÉªÉ´ Êá´á´œÊ€ É¢Ê€á´á´œá´˜s."
)

# --- Sub-Help Menu Content ---
HELP_COMMANDS_TEXT_MAP = {
    "couple": (
        "ğŸ“œ ğ‚á´á´œá´˜ÊŸá´‡ & ğ‹á´á´ á´‡ ğ‚á´á´á´á´€É´á´…s:\n"
        "/couples ~ ğ‚Êœá´á´sá´‡ á´§ Ê€á´§É´á´…á´á´ á´„á´á´œá´˜ÊŸá´‡\n"
        "/cute ~ ğ‚Êœá´‡á´„á´‹ Êá´á´œÊ€ á´„á´œá´›á´‡É´á´‡ss\n"
        "/love name1 + name2 ~ ğ’á´‡á´‡ ÊŸá´á´ á´‡ á´˜á´ssÉªÊ™ÉªÊŸÉªá´›Ê\n"
        "\n_á´§ÊŸÊŸ á´›Êœá´‡sá´‡ á´„á´á´á´á´€É´á´…s á´€Ê€á´‡ á´€á´ á´€ÉªÊŸá´€Ê™ÊŸá´‡ á´›á´ á´‡á´ á´‡Ê€Êá´É´á´‡."
    ),
    "chatbot": (
        "ğŸ“œ ğ‚Êœá´€á´›Ê™á´á´› ğ‚á´á´á´á´€É´á´…:\n"
        "/chatbot enable/disable ~ ğ„É´á´€Ê™ÊŸá´‡/á´…Éªsá´€Ê™ÊŸá´‡ á´„Êœá´€á´›Ê™á´á´›\n"
        "\n"
        "ğá´á´›á´‡: á´É´ÊŸÊ á´¡á´Ê€á´‹s ÉªÉ´ É¢Ê€á´á´œá´˜ á´€É´á´… á´É´ÊŸÊ Ò“á´Ê€ á´€á´…á´ÉªÉ´s/á´á´¡É´á´‡Ê€.\n"
        "ğ„xá´€á´á´˜ÊŸá´‡: /chatbot enable"
    ),
    "tools": (
        "ğŸ“œ ğ“á´á´ÊŸs ğ‚á´á´á´á´§É´á´…s:\n"
        "/id ~ ğ†á´‡á´› á´œsá´‡Ê€ ğˆá´… (Ê€á´‡á´˜ÊŸÊ á´Ê€ á´›á´§É¢)\n"
        "/tagall ~ ğ“á´§É¢ á´€ÊŸÊŸ á´á´‡á´Ê™á´‡Ê€s (ğ€á´…á´ÉªÉ´ ğÉ´ÊŸÊ)\n"
        "/stop ~ ğ“á´ sá´›á´á´˜ á´›á´§É¢É¢ÉªÉ´É¢ (ğ€á´…á´ÉªÉ´ ğÉ´ÊŸÊ)\n"
        "/afk reason ~ ğ€á´¡á´€Ê Ò“Ê€á´á´ á´›Êœá´‡ á´‹á´‡ÊÊ™á´á´€Ê€á´…\n"
        "\n_ğ“á´€É¢á´€ÊŸÊŸ/ğ’á´›á´á´˜ Ê€á´‡Ç«á´œÉªÊ€á´‡s ğ€á´…á´ÉªÉ´. ğá´›Êœá´‡Ê€s á´€Ê€á´‡ Ò“á´Ê€ á´‡á´ á´‡Ê€Êá´É´á´‡."
    ),
    "group": (
        "ğŸ“œ ğ†Ê€á´á´œá´˜ ğ”á´›ÉªÊŸÉªá´›Ê ğ‚á´á´á´á´§É´á´…s:\n"
        "/staff ~ ğƒÉªsá´˜ÊŸá´§Ês É¢Ê€á´á´œá´˜ sá´›á´§Ò“Ò“ á´á´‡á´Ê™á´‡Ê€s\n"
        "/botlist ~ ğ‚Êœá´‡á´„á´‹ Êœá´á´¡ á´á´€É´Ê Ê™á´á´›s ÉªÉ´ Êá´á´œÊ€ É¢Ê€á´á´œá´˜ (ğ€á´…á´ÉªÉ´ á´É´ÊŸÊ)\n"
        "/chatbot ~ ğ„É´á´€Ê™ÊŸá´‡/á´…Éªsá´€Ê™ÊŸá´‡ á´„Êœá´€á´›Ê™á´á´› (ğ€á´…á´ÉªÉ´ á´É´ÊŸÊ)\n"
        "\n_Ê™á´á´›ÊŸÉªsá´›/á´„Êœá´€á´›Ê™á´á´› Ê€á´‡Ç«á´œÉªÊ€á´‡s á´€á´…á´ÉªÉ´. á´á´›Êœá´‡Ê€s á´€Ê€á´‡ Ò“á´Ê€ á´‡á´ á´‡Ê€Êá´É´á´‡."
    )
}
# ----------------- FANCY FONTS END -----------------

# -------- STICKER MAPPING (User provided stickers) --------
STICKER_MAPPING = {
    # Cute Stickers
    "sticker_cute_1": "CAACAgEAAxkBAAEPgu9o4USg2JWyq8EjIQcHKAJxTISKnAAChwADUSkNOdIrExvjme5qNgQ",
    "sticker_cute_2": "CAACAgUAAxkBAAEPgvFo4USiv1_Mf9-45IeDMN5kETeB7AACzQ4AAsp_IVSL99zOZVfZeTYE", 
    # Funny Stickers
    "sticker_funny_1": "CAACAgQAAxkBAAEPguto4USNgkueY_8UUvG1qR0HO8pVJAAC8hEAAuKyeVAr0E__1DsLxTYE",
    "sticker_funny_2": "CAACAgUAAxkBAAEPgvFo4USiv1_Mf9-45IeDMN5kETeB7AACzQ4AAsp_IVSL99zOZVfZeTYE", 
    # Angry Stickers
    "sticker_anger_1": "CAACAgUAAxkBAAEPgudo4UR5HlLeS-qX6SPZa68uWVYxXAACNBAAAvyQWFdWZPeCGuC2gjYE",
    "sticker_anger_2": "CAACAgUAAxkBAAEPgulo4USHqBw08BmrpRAczQX6nqkQXQACsQIAAmfVCVXVlV0wAWPSXDYE",
    # Other/General Stickers - Mapped as placeholders for other categories
    "sticker_love_1": "CAACAgQAAxkBAAEPgu1o4USZaO5ewrgQV8bLpU6Y8z0d9AACXA4AAj9T-FN3FZM9W24oiTYE", 
    "sticker_anime_1": "CAACAgEAAxkBAAEPgu9o4USg2JWyq8EjIQcHKAJxTISKnAAChwADUSkNOdIrExvjme5qNgQ",
}

# --- Load Replies & Known Chats ---
try:
    with open("conversation.json", "r", encoding="utf-8") as f:
        DATA = json.load(f)
except:
    # If the JSON file is missing, use a minimal default structure with the new sticker IDs
    DATA = {
        "daily": ["Hello ğŸ‘‹", "Hey there!", "Hi!", "I'm here, what's up?"],
        "love": ["I love you too!","Aww, sending virtual hugs.","Love is in the air! ğŸ’–"],
        "sad": ["Don't be sad! I'm here for you.","Cheer up, friend! ğŸ˜Š"],
        "happy": ["That's great news! ğŸ¥³","Keep smiling!"],
        "bye": ["Bye bye! See you soon.","Tata! ğŸ‘‹"],
        "thanks": ["You're welcome!","Anytime, that's what I'm here for."],
        "morning": ["Good morning! Have a great day.â˜€ï¸","GM!"],
        "night": ["Good night! Sweet dreams.ğŸŒ™"],
        "abuse": ["Watch your language, please! ğŸš«","That's not very nice."],
        "question": ["I am a bot designed to help and chat with you!","What would you like to know?"],
        "anger": ["Take a deep breath. It's okay.","Sending calm vibes your way. ğŸ§˜"],

        # Sticker categories using user-provided IDs
        "sticker_cute": [
            STICKER_MAPPING["sticker_cute_1"], STICKER_MAPPING["sticker_cute_2"]
        ],
        "sticker_funny": [
            STICKER_MAPPING["sticker_funny_1"], STICKER_MAPPING["sticker_funny_2"]
        ],
        "sticker_anger": [
            STICKER_MAPPING["sticker_anger_1"], STICKER_MAPPING["sticker_anger_2"]
        ],
        "sticker_anime": [
            STICKER_MAPPING["sticker_anime_1"]
        ],
        "sticker_love": [
            STICKER_MAPPING["sticker_love_1"]
        ]
    }

if "daily" not in DATA:
    DATA["daily"] = ["Hello ğŸ‘‹", "Hey there!", "Hi!"]


CHAT_IDS_FILE = "chats.json"
if os.path.exists(CHAT_IDS_FILE):
    with open(CHAT_IDS_FILE, "r") as f:
        KNOWN_CHATS = json.load(f)
else:
    KNOWN_CHATS = {"groups": [], "privates": []}

# Combined Text and Sticker Keywords
KEYWORDS = {
    # Text Replies (from JSON)
    "love": "love", "i love you": "love", "miss you": "love", "crush": "love", "heart": "love",
    "sad": "sad", "cry": "sad", "depressed": "sad", "broken": "sad", "alone": "sad",
    "happy": "happy", "mast": "happy", "fun": "happy", "great": "happy", "cheers": "happy",
    "hello": "daily", "hi": "daily", "hey": "daily", "yaar": "daily", "kya haal": "daily", "bhai": "daily",
    "bye": "bye", "goodbye": "bye", "see ya": "bye", "tata": "bye",
    "thanks": "thanks", "thank you": "thanks", "tysm": "thanks",
    "gm": "morning", "good morning": "morning", "subah": "morning",
    "gn": "night", "good night": "night", "shubh ratri": "night", "sleep": "night",
    "chutiya": "abuse", "bc": "abuse", "mc": "abuse", "pagal": "abuse", "idiot": "abuse",
    "kaisa hai": "question", "kya kar raha": "question", "who are you": "question", "bot": "question",
    "gussa": "anger", "angry": "anger", "gali": "anger",

    # Sticker Replies (New Categories)
    "hahaha": "sticker_funny", "lol": "sticker_funny", "rofl": "sticker_funny", "funny": "sticker_funny",
    "cute": "sticker_cute", "aww": "sticker_cute", "so sweet": "sticker_cute", "baby": "sticker_cute",
    "anime": "sticker_anime", "manga": "sticker_anime",
    "i hate you": "sticker_anger", "go away": "sticker_anger", "mad": "sticker_anger",
}

# -------- Utility Functions --------
def get_reply(text: str):
    """
    Determines the response (text or sticker ID) based on the input text.
    Returns (response, is_sticker)
    """
    if not text:
        # Fall back to daily text
        return (random.choice(DATA.get("daily", ["Hello ğŸ‘‹"])), False)

    text = text.lower()
    
    # Simple normalization: remove non-alphanumeric except spaces for better keyword matching
    text = re.sub(r'[^\w\s]', '', text) 
    
    for word, cat in KEYWORDS.items():
        # Check if keyword is a substring of the message text
        if word in text:
            if cat.startswith("sticker_") and cat in DATA and DATA[cat]:
                # Returns a random sticker ID from the category (is_sticker=True)
                sticker_id = random.choice(DATA[cat])
                return (sticker_id, True) 
            elif cat in DATA and DATA[cat]:
                # Returns a random text reply (is_sticker=False)
                return (random.choice(DATA[cat]), False)
    
    # If no specific keyword is found, return None to indicate a general reply should not be sent
    # This logic is shifted to the main message handler to implement the 80% rule for general chat.
    return (None, False)

def get_readable_time(seconds: int) -> str:
    result = ''
    (days, remainder) = divmod(seconds, 86400)
    (hours, remainder) = divmod(remainder, 3600)
    (minutes, seconds) = divmod(remainder, 60)
    if days > 0:
        result += f"{days}d "
    if hours > 0:
        result += f"{hours}h "
    if minutes > 0:
        result += f"{minutes}m "
    if seconds > 0:
        result += f"{seconds}s"
    return result.strip() or "just now"

async def is_admin(chat_id, user_id):
    """Checks if a user is an admin or owner of the chat."""
    # Check if the user is the bot owner first (global admin)
    if user_id == OWNER_ID:
        return True
    try:
        member = await app.get_chat_member(chat_id, user_id)
        return member.status in [enums.ChatMemberStatus.OWNER, enums.ChatMemberStatus.ADMINISTRATOR]
    except Exception:
        return False

async def is_bot_admin(chat_id):
    """Checks if the bot is an admin in the chat."""
    try:
        me = await app.get_me()
        member = await app.get_chat_member(chat_id, me.id)
        return member.status in [enums.ChatMemberStatus.OWNER, enums.ChatMemberStatus.ADMINISTRATOR]
    except Exception:
        return False

async def save_chat_id(chat_id, type_):
    """Saves the chat ID to the known chats list."""
    chat_id_str = str(chat_id)
    
    if chat_id_str not in KNOWN_CHATS[type_]:
        KNOWN_CHATS[type_].append(chat_id_str)
        # Write to file asynchronously in an ideal scenario, but synchronous for simplicity here
        with open(CHAT_IDS_FILE, "w") as f:
            json.dump(KNOWN_CHATS, f)

# Custom filter for checking chatbot status
def is_chatbot_enabled(_, __, message: Message):
    """Returns True if chatbot is enabled for this group."""
    if message.chat.type in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        # Default is False, so only True if explicitly set to True
        return CHATBOT_STATUS.get(message.chat.id, False)
    return False # Chatbot should run in private chats via the main handler

# -------- Inline Button Handlers & Menus --------

# --- Menu Builder Functions ---
def get_start_buttons(bot_username):
    """Returns the main start button layout."""
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("â• ğ€ğğ ğŒğ ğ“ğ¨ ğ˜ğ¨ğ®ğ« ğ†ğ«ğ¨ğ®ğ© â•", url=f"https://t.me/{bot_username}?startgroup=true")],
        [
            InlineKeyboardButton("á¯“âá´¡É³ğ›†Ê€", user_id=OWNER_ID),
            InlineKeyboardButton("â—‰ ğ€Ê™á´á´œá´›", callback_data="about")
        ],
        [InlineKeyboardButton("â—‰ ğ‡á´‡ÊŸá´˜ & ğ‚á´á´á´á´€É´á´…s", callback_data="help_main")]
    ])

def get_about_buttons():
    """Returns the About section button layout."""
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("ğ„á´ á´€Ê€á´€ ğ’á´œá´˜á´˜á´Ê€á´› ğ‚Êœá´€á´›", url=SUPPORT_CHAT),
            InlineKeyboardButton("ğ”á´˜á´…á´€á´›á´‡s", url=UPDATES_CHANNEL)
        ],
        [
            InlineKeyboardButton("â€¢ ğá´€á´„á´‹", callback_data="start_back"),
            InlineKeyboardButton("â€¢ ğ‚ÊŸá´sá´‡", callback_data="close")
        ]
    ])

def get_help_main_buttons():
    """Returns the main Help & Commands button layout."""
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("á´„á´á´œá´˜ÊŸá´‡", callback_data="help_couple"),
            InlineKeyboardButton("á´„Êœá´€á´›Ê™á´á´›", callback_data="help_chatbot")
        ],
        [
            InlineKeyboardButton("á´›á´á´ÊŸs", callback_data="help_tools"),
            InlineKeyboardButton("É¢Ê€á´á´œá´˜", callback_data="help_group") # Replaced 'games' with 'group' in this row
        ],
        [
            InlineKeyboardButton("ğá´€á´„á´‹", callback_data="start_back"),
            InlineKeyboardButton("ğ‚ÊŸá´sá´‡", callback_data="close")
        ]
    ])

# --- Callbacks Handler ---
@app.on_callback_query()
async def callbacks_handler(client, query):
    data = query.data
    user = query.from_user
    me = await app.get_me()
    
    # Simple check for the user who initiated the command in groups
    if query.message.chat.type != enums.ChatType.PRIVATE:
        try:
            # Check if the user is the one who pressed the button (optional security)
            # You might want to remove this if you want anyone to press the menu buttons.
            # if query.message.reply_to_message and query.from_user.id != query.message.reply_to_message.from_user.id:
            #     return await query.answer("This menu is not for you.", show_alert=True)
            pass
        except Exception:
            pass # Ignore if no reply to message

    if data == "about":
        await query.message.edit_caption(
            caption=ABOUT_TEXT,
            reply_markup=get_about_buttons()
        )
    elif data == "start_back":
        await query.message.edit_caption(
            caption=INTRO_TEXT_TEMPLATE.format(
                mention_name=f"[{user.first_name}](tg://user?id={user.id})",
                developer=DEVELOPER_USERNAME,
            ),
            reply_markup=get_start_buttons(me.username),
            parse_mode=enums.ParseMode.MARKDOWN
        )
    elif data == "help_main":
        await query.message.edit_caption(
            caption="ğŸ“œ ğ‚á´á´á´á´€É´á´…s ğŒá´‡É´á´œ:\n\nğ‚Êœá´á´sá´‡ á´€ á´„á´€á´›á´‡É¢á´Ê€Ê Ê™á´‡ÊŸá´á´¡:",
            reply_markup=get_help_main_buttons()
        )
    elif data.startswith("help_"):
        category = data.split("_")[1]
        text = HELP_COMMANDS_TEXT_MAP.get(category, "ğ„Ê€Ê€á´Ê€: ğ”É´á´‹É´á´á´¡É´ ğ‚á´€á´›á´‡É¢á´Ê€Ê")
        
        # Custom button logic for sub-menus
        buttons = []
        if category in ["couple", "cute", "love"]:
            buttons.append(InlineKeyboardButton("âœ¦ ğ’á´œá´˜á´˜á´Ê€á´›", url=SUPPORT_CHAT))
            
        # Ensure buttons is a list of lists for InlineKeyboardMarkup
        buttons_markup_rows = []
        if buttons:
            buttons_markup_rows.append(buttons)
        buttons_markup_rows.append([
            InlineKeyboardButton("ğá´€á´„á´‹", callback_data="help_main"),
            InlineKeyboardButton("ğ‚ÊŸá´sá´‡", callback_data="close")
        ])
        
        await query.message.edit_caption(
            caption=text,
            reply_markup=InlineKeyboardMarkup(buttons_markup_rows)
        )
    elif data == "close":
        await query.message.delete()
    else:
        await query.answer("ğ“ÊœÉªs Ê™á´œá´›á´›á´É´ Éªs É´á´á´› Êá´‡á´› ğ…á´œÉ´á´„á´›ÉªğNğ€ğ‹.") 

# -------- Commands --------

# -------- New Member Welcome Handler (FIXED & ADDED) --------
@app.on_message(filters.new_chat_members & filters.group)
async def welcome_new_member(client, message):
    me = await client.get_me()
    for user in message.new_chat_members:
        if user.id == me.id:
            # Bot was added to the group
            await message.reply_text("ğ“Êœá´€É´á´‹s Ò“á´Ê€ á´€á´…á´…ÉªÉ´É¢ á´á´‡ !! ğŸ’–\n\nğˆ á´€á´ á´€É´ á´€á´…á´ á´€É´á´„á´‡á´… á´„Êœá´€á´›Ê™á´á´›. ğ”sá´‡ /help á´›á´ É¢á´‡á´› sá´›á´€Ê€á´›á´‡á´….\n\n_ğğğ“ğ„: ğğ¥ğğšğ¬ğ ğ¦ğšğ¤ğ ğ¦ğ ğ€ğƒğŒğˆğ ğŸğ¨ğ« ğŸğ®ğ¥ğ¥ ğŸğ®ğ§ğœğ­ğ¢ğ¨ğ§ğšğ¥ğ¢ğ­ğ²._")
            await save_chat_id(message.chat.id, "groups")
            # Default to chatbot disabled
            CHATBOT_STATUS[message.chat.id] = False 
            break
        else:
            # A user was added
            mention = f"[{user.first_name}](tg://user?id={user.id})"
            await message.reply_text(f"ğŸ‘‹ ğ–á´‡ÊŸá´„á´á´á´‡ {mention} á´›á´ á´›Êœá´‡ É¢Ê€á´á´œá´˜! ğ„É´á´Šá´Ê Êá´á´œÊ€ sá´›á´€Ê.")
    
# -------- /start Command --------
# Combined start handler for both private and groups
@app.on_message(filters.command("start"))
async def start_cmd(client, message):
    user = message.from_user
    me = await app.get_me()
    
    if message.chat.type == enums.ChatType.PRIVATE:
        # Ding Dong Animation
        anim_text = "á´…ÉªÉ´É¢...á´…á´É´É¢ ğŸ’¥....Ê™á´á´› Éªs sá´›á´€Ê€á´›ÉªÉ´É¢"
        msg = await message.reply_text("Starting...")
        
        current = ""
        for ch in anim_text:
            current += ch
            try:
                await msg.edit(current)
            except:
                pass
            await asyncio.sleep(0.05)
            
        await asyncio.sleep(0.5)
        
        try:
            await msg.delete()
        except:
            pass 
        
        await message.reply_photo(
            START_PHOTO,
            caption=INTRO_TEXT_TEMPLATE.format(
                mention_name=f"[{user.first_name}](tg://user?id={user.id})",
                developer=DEVELOPER_USERNAME,
            ),
            reply_markup=get_start_buttons(me.username),
            parse_mode=enums.ParseMode.MARKDOWN,
            has_spoiler=True # Added spoiler effect
        )
        await save_chat_id(message.chat.id, "privates")
    else:
        # Group start message
        await message.reply_text(
            f"ğ‡á´‡Ê [{user.first_name}](tg://user?id={user.id})! ğˆ ğšğ¦ ğ«ğğšğğ² ğ­ğ¨ ğœğ¡ğšğ­. ğ‚ğ¥ğ¢ğœğ¤ ğ¨ğ§ /help ğŸğ¨ğ« ğ¦ğ¨ğ«ğ ğ¢ğ§ğŸğ¨.",
            parse_mode=enums.ParseMode.MARKDOWN
        )
        await save_chat_id(message.chat.id, "groups")

# -------- /developer Command --------
@app.on_message(filters.command("developer"))
async def developer_cmd(client, message):
    # Animation
    anim_text = "ğ˜á´á´œ ğ–á´€É³á´› á´›á´ ğŠÉ³á´á´¡..ğ“ÊœÉªs ğá´á´› ğƒá´‡á´ á´‡ÊŸá´á´˜á´‡Ê€ ğŸ’¥..ğ‡á´‡Ê€á´‡"
    m = await message.reply_text("Searching...")
    
    current = ""
    for ch in anim_text:
        current += ch
        try:
            await m.edit(current)
        except:
            pass
        await asyncio.sleep(0.05)
        
    await asyncio.sleep(0.5)
    
    # Try to delete the animation message
    try:
        await m.delete()
    except:
        pass 
        
    buttons = InlineKeyboardMarkup([
        [InlineKeyboardButton("ğƒá´‡á´ á´‡ÊŸá´á´˜á´‡Ê€ áƒ¦", url=f"https://t.me/{DEVELOPER_HANDLE.strip('@')}")]
    ])
    
    caption_text = f"ğá´á´› ğƒá´‡á´ á´‡ÊŸá´á´˜á´‡Ê€ Éªs [{DEVELOPER_USERNAME}](t.me/{DEVELOPER_HANDLE.strip('@')})"
    
    try:
        # 1. Try to send the photo response
        await message.reply_photo(
            DEVELOPER_PHOTO,
            caption=caption_text,
            reply_markup=buttons,
            parse_mode=enums.ParseMode.MARKDOWN
        )
    except Exception as e:
        # 2. Fallback to text message if photo sending fails (ensures a response)
        await message.reply_text(
            caption_text,
            reply_markup=buttons,
            parse_mode=enums.ParseMode.MARKDOWN
        )
        print(f"Error sending developer photo: {e}") # Log the error 

# -------- /ping Command --------
@app.on_message(filters.command("ping"))
async def ping_cmd(client, message):
    start = time.time()
    
    # Ping animation
    m = await message.reply_text("PÉªÉ´É¢ÉªÉ´É¢...sá´›á´€Ê€á´›á´‡á´…..Â´ï½¥á´—ï½¥")
    await asyncio.sleep(0.5)
    await m.edit_text("PÉªÉ´É¢..Pá´É´É¢ âš¡")
    await asyncio.sleep(0.5)
    
    end = time.time()
    ping_ms = round((end-start)*1000)
    uptime_seconds = (datetime.now() - START_TIME).total_seconds()
    uptime_readable = get_readable_time(int(uptime_seconds))
    me = await client.get_me()
    
    buttons = InlineKeyboardMarkup([
        [InlineKeyboardButton("â• ğ€á´…á´… ğŒá´‡ â•", url=f"https://t.me/{me.username}?startgroup=true")],
        [InlineKeyboardButton("ğ’á´œÏÏá´É¾á´›", url=SUPPORT_CHAT)]
    ])
    
    try:
        await m.delete() # Delete the animation message
    except:
        pass
        
    await message.reply_photo(
        PING_PHOTO,
        caption=f"ğÉªÉ´É¢ â³ {ping_ms} ğ¦ğ¬\n"
                f"ğ”á´˜á´›Éªá´á´‡ â³ {uptime_readable}",
        reply_markup=buttons
    ) 

# -------- /id Command --------
@app.on_message(filters.command("id"))
async def id_cmd(client, message): 
    # Get the user to check ID for: replied user or message sender
    user = message.reply_to_message.from_user if message.reply_to_message and message.reply_to_message.from_user else message.from_user 
    await message.reply_text(f"ğŸ‘¤ {user.first_name}\nğŸ†” {user.id}")

# -------- /stats Command (Owner Only) --------
@app.on_message(filters.command("stats") & filters.user(OWNER_ID))
async def stats_cmd(client, message):
    await message.reply_text(f"ğŸ“Š ğá´á´› ğ’á´›á´€á´›s:\nğŸ‘¥ ğ†Ê€á´á´œá´˜s: {len(KNOWN_CHATS['groups'])}\nğŸ‘¤ ğÊ€Éªá´ á´€á´›á´‡s: {len(KNOWN_CHATS['privates'])}")

# -------- /broadcast (Owner Only) --------
@app.on_message(filters.command("broadcast") & filters.user(OWNER_ID))
async def broadcast_cmd(client, message):
    if not (message.reply_to_message or len(message.command) > 1):
        return await message.reply_text("á´œsá´€É¢á´‡: /Ê™Ê€á´á´€á´…á´„á´€sá´› á´Ê€ Ê€á´‡á´˜ÊŸÊ á´›á´ á´€ á´á´‡ssá´€É¢á´‡.")
    
    # Extract content to broadcast
    content_to_send = None
    text = None
    if message.reply_to_message:
        content_to_send = message.reply_to_message
    elif len(message.command) > 1:
        text = message.text.split(None, 1)[1]
    else:
        return # Should be caught by the first check, but for safety

    sent = 0
    failed = 0
    m = await message.reply_text("ğ’á´›á´€Ê€á´›ÉªÉ´É¢ ğÊ€á´á´€á´…á´„á´€sá´›...")
    
    # Iterate over a combined list of chat IDs
    for chat_id_str in KNOWN_CHATS["privates"] + KNOWN_CHATS["groups"]:
        try:
            chat_id = int(chat_id_str) 
            
            if content_to_send:
                # Use client.copy_message for reliable forwarding/copying
                await client.copy_message(chat_id, message.chat.id, content_to_send.id)
            elif text:
                await app.send_message(chat_id, text)
            
            sent += 1
            # Simple rate limiting for large broadcasts
            await asyncio.sleep(0.2) 
        except (FloodWait, UserNotParticipant, ChatWriteForbidden, PeerIdInvalid, RPCError):
            # Log specific Pyrogram errors that often happen during broadcast
            failed += 1
            continue
        except Exception:
            # Catch other potential errors
            failed += 1
            continue 
            
    await m.edit_text(f"âœ… ğÊ€á´á´€á´…á´„á´€sá´› á´…á´É´á´‡!\nğ’á´‡É´á´› á´›á´ {sent} á´„Êœá´€á´›s.\nğ…á´€ÉªÊŸá´‡á´… ÉªÉ´ {failed} á´„Êœá´€á´›s.")

# -------- /chatbot Toggle --------
@app.on_message(filters.command("chatbot") & filters.group)
async def chatbot_toggle(client, message):
    if not await is_admin(message.chat.id, message.from_user.id):
        return await message.reply_text("â— OÉ´ÊŸÊ á´€á´…á´ÉªÉ´s á´€É´á´… á´á´¡É´á´‡Ê€ á´„á´€É´ á´œsá´‡ á´›ÊœÉªs á´„á´á´á´á´€É´á´….")
    
    if len(message.command) < 2:
        # Show current status if no argument given
        current_status = "ğ„ğğ€ğğ‹ğ„ğƒ" if CHATBOT_STATUS.get(message.chat.id, False) else "ğƒğˆğ’ğ€ğğ‹ğ„ğƒ"
        return await message.reply_text(f"ğ‚Êœá´€á´›Ê™á´á´› Éªs á´„á´œÊ€Ê€á´‡É´á´›ÊŸÊ {current_status} âœ°\nğ”sá´€É¢á´‡: /á´„Êœá´€á´›Ê™á´á´› á´‡É´á´€Ê™ÊŸá´‡ á´Ê€ /á´„Êœá´€á´›Ê™á´á´› á´…Éªsá´€Ê™ÊŸá´‡")
        
    mode = message.command[1].lower()
    
    if mode in ["on", "enable"]:
        CHATBOT_STATUS[message.chat.id] = True
        status_text = "enabled"
        await message.reply_text(f"ğ‚Êœá´€á´›Ê™á´á´› sá´›á´€á´›á´œs Éªs {status_text.upper()} âœ°")
    elif mode in ["off", "disable"]:
        CHATBOT_STATUS[message.chat.id] = False
        status_text = "disabled"
        await message.reply_text(f"ğ‚Êœá´€á´›Ê™á´á´› sá´›á´€á´›á´œs Éªs {status_text.upper()} âœ°")
    else:
        return await message.reply_text("ğ”sá´€É¢á´‡: /á´„Êœá´€á´›Ê™á´á´› á´‡É´á´€Ê™ÊŸá´‡ á´Ê€ /á´„Êœá´€á´›Ê™á´á´› á´…Éªsá´€Ê™ÊŸá´‡")
        
    await save_chat_id(message.chat.id, "groups") 

# -------- /tagall Command (FIXED) --------
@app.on_message(filters.command("tagall") & filters.group)
async def tagall_cmd(client, message):
    if not await is_admin(message.chat.id, message.from_user.id):
        return await message.reply_text("â— ğÉ´ÊŸÊ á´€á´…á´ÉªÉ´s á´„á´€É´ á´œsá´‡ /á´›á´€É¢á´€ÊŸÊŸ.")
    
    if not await is_bot_admin(message.chat.id):
        return await message.reply_text("â— ğˆ É´á´‡á´‡á´… á´€á´…á´ÉªÉ´ á´˜á´‡Ê€á´ÉªssÉªá´É´ (á´›á´€É¢ á´á´‡á´Ê™á´‡Ê€s) á´›á´ á´œsá´‡ á´›ÊœÉªs á´„á´á´á´á´€É´á´….")

    chat_id = message.chat.id # FIX: Correctly get chat_id
    
    if TAGGING.get(chat_id): # FIX: Check for current tagging status
        return await message.reply_text("â— ğ€ÊŸÊ€á´‡á´€á´…Ê á´›á´€É¢É¢ÉªÉ´É¢ ÉªÉ´ á´›ÊœÉªs á´„Êœá´€á´›. ğ”sá´‡ /sá´›á´á´˜ á´›á´ á´„á´€É´á´„á´‡ÊŸ.")
        
    TAGGING[chat_id] = True
    
    # Get message content
    if len(message.command) > 1:
        msg = message.text.split(None, 1)[1]
    elif message.reply_to_message and message.reply_to_message.text:
        msg = f"{message.reply_to_message.text[:50]}{'...' if len(message.reply_to_message.text) > 50 else ''}" # Preview of replied message text
    else:
        msg = "ğ€á´›á´›á´‡É´á´›Éªá´É´!"
        
    m = await message.reply_text("ğ“á´€É¢É¢ÉªÉ´É¢ ğ’á´›á´€Ê€á´›á´‡á´… !! â™¥")
    
    member_list = []
    # Collect all members first
    try:
        # Use get_chat_members(limit=0) to get all members efficiently
        async for member in app.get_chat_members(chat_id, limit=0):
            if not (member.user.is_bot or member.user.is_deleted):
                member_list.append(member.user)
    except Exception:
        TAGGING[chat_id] = False
        return await m.edit_text("ğŸš« ğ„ğ«ğ«ğ¨ğ« ğ¢ğ§ ğŸğğ­ğœğ¡ğ¢ğ§ğ  ğ¦ğğ¦ğ›ğğ«s: ğŒğšğ²ğ›ğ ğ­ğ¡ğ¢s ğ ğ«ğ¨ğ®ğ© ğ¢s ğ­ğ¨ğ¨ ğ›ğ¢ğ  ğ¨ğ« ğˆ ğğ¨ğ§'t ğ¡ğšğ¯ğ ğ©ğğ«ğ¦ğ¢ğ¬ğ¬ğ¢ğ¨ğ§s.")

    # Start tagging in chunks
    chunk_size = 5
    for i in range(0, len(member_list), chunk_size):
        if not TAGGING.get(chat_id):
            break
            
        chunk = member_list[i:i + chunk_size]
        tag_text = f"**{msg}**\n\n" # Use bold for emphasis
        
        for user in chunk:
            tag_text += f"[{user.first_name}](tg://user?id={user.id}) "
            
        try:
            # Send the tag chunk
            await app.send_message(chat_id, tag_text, disable_web_page_preview=True, parse_mode=enums.ParseMode.MARKDOWN)
            await asyncio.sleep(2) # Delay to avoid flooding limits
        except:
            continue
            
    # Final message update
    if TAGGING.get(chat_id):
        await m.edit_text("ğ“á´€É¢É¢ÉªÉ´É¢ ğ‚á´á´á´˜ÊŸá´‡á´›á´‡á´… !! â—‰â€¿â—‰")
        TAGGING[chat_id] = False 

# -------- /stop Tagging --------
@app.on_message(filters.command("stop") & filters.group)
async def stop_tag(client, message):
    if not await is_admin(message.chat.id, message.from_user.id):
        return await message.reply_text("â— ğÉ´ÊŸÊ á´€á´…á´ÉªÉ´s á´„á´€É´ á´œsá´‡ /sá´›á´á´˜.")
        
    if TAGGING.get(message.chat.id):
        TAGGING[message.chat.id] = False
        await message.reply_text("ğ“á´€É¢É¢ÉªÉ´É¢ ğ’á´›á´á´˜á´˜á´‡á´… !!")
    else:
        await message.reply_text("â— ğá´ ğ“á´€É¢É¢ÉªÉ´É¢ Éªs ğ‚á´œÊ€Ê€á´‡É´á´›ğ¥ğ² ğ‘á´œğğÉªÉ´É¢.")

# -------- /couples, /cute, /love Commands (FIXED) --------
@app.on_message(filters.command("couples") & filters.group) # FIX: Added the decorator
async def couples_cmd(client, message):
    member_list = []
    try:
        # Use only USERS in the group, excluding bots and deleted accounts
        async for member in app.get_chat_members(message.chat.id, limit=0):
            if not (member.user.is_bot or member.user.is_deleted):
                member_list.append(member.user)
    except Exception:
        return await message.reply_text("ğŸš« ğ‚ğšğ§ğ§ğ¨ğ­ ğŸğğ­ğœğ¡ ğ¦ğğ¦ğ›ğğ«s ğğ®ğ ğ­ğ¨ ğ«ğğ¬ğ­ğ«ğ¢ğœğ­ğ¢ğ¨ğ§s.")

    if len(member_list) < 2:
        return await message.reply_text("â— ğá´‡á´‡á´… á´€á´› ÊŸá´‡á´€sá´› á´›á´¡á´ á´á´‡á´Ê™á´‡Ê€s á´›á´ Ò“á´Ê€á´ á´€ ğ‚á´á´œá´˜ğ¥á´‡.")
        
    # Pick two random unique members
    couple = random.sample(member_list, 2)
    user1 = couple[0]
    user2 = couple[1]
    
    # Calculate a random love percentage (just for fun)
    love_percent = random.randint(30, 99)
    
    await message.reply_text(
        f"ğŸ’˜ ğá´‡á´¡ ğ‚á´á´œá´˜ğ¥á´‡ á´Ò“ á´›Êœá´‡ ğƒá´€Ê!\n\n"
        f"[{user1.first_name}](tg://user?id={user1.id}) ğŸ’– [{user2.first_name}](tg://user?id={user2.id})\n"
        f"ğ‹á´á´ á´‡ ÊŸá´‡á´ á´‡ÊŸ Éªs {love_percent}%! ğŸ‰",
        parse_mode=enums.ParseMode.MARKDOWN
    )

@app.on_message(filters.command("cute"))
async def cute_cmd(client, message): 
    cute_level = random.randint(30, 99)
    user = message.from_user
    # FIX: Ensure user mention works
    user_mention = f"[{user.first_name}](tg://user?id={user.id})"
    text = f"{user_mention}â€™ğ¬ á´„á´œá´›á´‡É´á´‡ss ÊŸá´‡á´ á´‡ÊŸ Éªs {cute_level}% ğŸ’–"
    buttons = InlineKeyboardMarkup([[InlineKeyboardButton("ğ’á´œá´˜á´˜á´Ê€á´›", url=SUPPORT_CHAT)]])
    await message.reply_text(text, reply_markup=buttons, parse_mode=enums.ParseMode.MARKDOWN)

@app.on_message(filters.command("love"))
async def love_cmd(client, message):
    if len(message.command) < 2 or "+" not in message.text:
        return await message.reply_text("ğ”sá´€É¢á´‡: /ÊŸá´á´ á´‡ ğ…ÉªÊ€sá´› ğá´€á´á´‡ + ğ’á´‡á´„á´É´á´… ğá´€á´á´‡")

    # Split the argument and clean it up
    arg_text = message.text.split(None, 1)[1]
    names = [n.strip() for n in arg_text.split("+") if n.strip()]
    
    if len(names) < 2:
        return await message.reply_text("ğÊŸá´‡á´€sá´‡ á´˜Ê€á´á´ Éªá´…á´‡ á´›á´¡á´ É´á´€á´á´‡s sá´‡á´˜Ê€á´€á´›á´‡á´… Ê™Ê á´€ '+' (á´‡.É¢., /ÊŸá´á´ á´‡ ğ€ÊŸÉªá´„á´‡ + ğá´Ê™)")
        
    # FIX: Added love_percent calculation
    love_percent = random.randint(30, 99)

    text = f"â¤ï¸ ğ‹á´á´ á´‡ ğá´ssÉªÊ™ğ¥Éªá´›Ê\n" \
               f"{names[0]} & {names[1]}â€™ğ¬ ÊŸá´á´ á´‡ ÊŸá´‡á´ á´‡ÊŸ Éªs {love_percent}% ğŸ˜‰"
            
    buttons = InlineKeyboardMarkup([[InlineKeyboardButton("ğ’á´œá´˜á´˜á´Ê€á´›", url=SUPPORT_CHAT)]])
    await message.reply_text(text, reply_markup=buttons) 

# -------- /afk Command (FIXED) --------
@app.on_message(filters.command("afk")) 
async def afk_cmd(client, message): 
    user_id = message.from_user.id
    user_name = message.from_user.first_name
    
    # 1. Check if user is already AFK (meaning they are typing /afk to return)
    if user_id in AFK_USERS:
        # User is coming back
        afk_data = AFK_USERS.pop(user_id)
        time_afk = get_readable_time(int(time.time() - afk_data["time"]))
        await message.reply_text(
            f"ğ˜á´‡á´€Êœ, [{user_name}](tg://user?id={user_id}), Êá´á´œ ğšğ«ğ Ê™á´€á´„á´‹, á´É´ÊŸÉªÉ´á´‡! (ğ€Ò“á´‹ Ò“á´Ê€: {time_afk}) ğŸ˜‰",
            parse_mode=enums.ParseMode.MARKDOWN
        )
        return # Stop execution after returning
        
    # 2. If not returning, user is setting AFK status
    try:
        # Get the reason if provided
        reason = message.text.split(None, 1)[1] 
    except IndexError:
        reason = "ğá´ Ê€á´‡á´€sá´É´ É¢Éªá´ á´‡É´."
    
    # Store AFK status
    AFK_USERS[user_id] = {
        "reason": reason,
        "chat_id": message.chat.id,
        "username": message.from_user.username or user_name,
        "first_name": user_name,
        "time": time.time()
    }
    
    # Send the AFK message
    await message.reply_text(
        f"ğ‡á´‡Ê, [{user_name}](tg://user?id={user_id}), Êá´á´œ ğšğ«ğ ğ€Ò“á´‹! (ğ‘á´‡á´€sá´É´: {reason})",
        parse_mode=enums.ParseMode.MARKDOWN
    )

# -------- /mmf Command (Disabled) --------
@app.on_message(filters.command("mmf"))
async def mmf_cmd(client, message):
    # This command is intentionally simplified to a disabled message as image manipulation libraries
    # are often complex to set up in cloud environments.
    
    await message.reply_text(
        "âŒ ğ’ğ­ğ¢ğœğ¤ğğ« ğ“ğğ±ğ­ ğ…ğğšğ­ğ®ğ«ğ ğ”ğ§ğšğ¯ğšğ¢ğ¥ğšğ›ğ¥ğ\n"
        "ğğ¥ğğšğ¬ğ ğ§ğ¨ğ­ğ: ğ“ğ¡ğ¢ğ¬ ğœğ¨ğ¦ğ¦ğšğ§ğ ğ¢ğ¬ ğ­ğğ¦ğ©ğ¨ğ«ğšğ«ğ¢ğ¥ğ² ğğ¢ğ¬ğšğ›ğ¥ğğ ğğ®ğ ğ­ğ¨ ğ¦ğ¢ğ¬ğ¬ğ¢ğ§ğ  ğ¢ğ¦ğšğ ğ ğ©ğ«ğ¨ğœğğ¬ğ¬ğ¢ğ§ğ  ğ¥ğ¢ğ›ğ«ğšğ«ğ¢ğs. "
        "ğˆ á´€á´ á´¡á´Ê€á´‹ÉªÉ´É¢ á´É´ Éªá´›!"
    ) 

# -------- /staff Command (FIXED) --------
@app.on_message(filters.command("staff") & filters.group)
async def staff_cmd(client, message):
    try:
        admins = []
        # FIX: Correct loop for fetching members and applying the filter
        async for admin in app.get_chat_members(message.chat.id, filter=enums.ChatMembersFilter.ADMINISTRATORS):
            admins.append(admin)
        
        staff_list = "ğŸ‘‘ ğ†Ê€á´á´œá´˜ ğ’á´›á´€Ò“Ò“ ğŒá´‡á´Ê™á´‡Ê€s:\n\n"
        
        if not admins:
            staff_list += "ğá´ ğšğğ¦ğ¢ğ§s ğŸğ¨ğ®ğ§ğ."
        else:
            for admin in admins: 
                # Skip deleted accounts
                if admin.user.is_deleted:
                    continue
                    
                tag = f"[{admin.user.first_name}](tg://user?id={admin.user.id})"
                
                # Determine status and append to list
                if admin.status == enums.ChatMemberStatus.OWNER:
                    staff_list += f"â€¢ ğŸ‘‘ {tag} (Owner)\n"
                elif admin.user.is_bot:
                    # Exclude the bot itself from the 'human' staff list
                    if admin.user.id == (await client.get_me()).id:
                        continue 
                    staff_list += f"â€¢ ğŸ¤– {tag} (Bot Admin)\n"
                else: # Regular human administrator
                    staff_list += f"â€¢ ğŸ›¡ï¸ {tag} (Admin)\n"
                
        await message.reply_text(staff_list, parse_mode=enums.ParseMode.MARKDOWN)
        
    except Exception as e:
        print(f"Error fetching staff: {e}")
        await message.reply_text(f"ğŸš« ğ„ğ«ğ«ğ¨ğ« ğ¢ğ§ ğŸğğ­ğœğ¡ğ¢ğ§ğ  ğ¬ğ­ğšğŸğŸ: ğŒğšğ²ğ›ğ ğˆ ğğ¨ğ§'t ğ¡ğšğ¯ğ ğšğğ¦ğ¢ğ§ ğ©ğğ«ğ¦ğ¢ğ¬ğ¬ğ¢ğ¨ğ§s.")

# -------- /botlist Command (NEW & FIXED) --------
@app.on_message(filters.command("botlist") & filters.group)
async def botlist_cmd(client, message):
    if not await is_admin(message.chat.id, message.from_user.id):
        return await message.reply_text("â— OÉ´ÊŸÊ á´€á´…á´ÉªÉ´s á´€É´á´… á´á´¡É´á´‡Ê€ á´„á´€É´ á´œsá´‡ á´›ÊœÉªs á´„á´á´á´á´€É´á´….")
    
    bot_count = 0
    bot_list = "ğŸ¤– ğğ¨ğ­ğ¬ ğ¢ğ§ ğ“ğ¡ğ¢ğ¬ ğ†ğ«ğ¨ğ®ğ©:\n\n"
    
    try:
        # Get all members
        async for member in app.get_chat_members(message.chat.id, limit=0):
            if member.user.is_bot and not member.user.is_deleted:
                bot_count += 1
                bot_list += f"â€¢ {member.user.first_name} (@{member.user.username or 'No Username'})\n"
        
        bot_list = f"ğŸ“Š ğ“ğ¨ğ­ğšğ¥ ğğ¨ğ­ğ¬ ğ…ğ¨ğ®ğ§ğ: **{bot_count}**\n\n" + bot_list
        await message.reply_text(bot_list, parse_mode=enums.ParseMode.MARKDOWN)

    except Exception as e:
        print(f"Error fetching bot list: {e}")
        await message.reply_text(f"ğŸš« ğ„ğ«ğ«ğ¨ğ« ğ¢ğ§ ğŸğğ­ğœğ¡ğ¢ğ§ğ  ğ›ğ¨ğ­ ğ¥ğ¢ğ¬ğ­: ğŒğšğ²ğ›ğ ğˆ ğğ¨ğ§'t ğ¡ğšğ¯ğ ğ©ğğ«ğ¦ğ¢ğ¬ğ¬ğ¢ğ¨ğ§ğ¬.")

# -------- AFK Mentions Handler (FIXED) --------
@app.on_message(filters.mentioned | filters.reply & ~filters.bot, group=1) # Group 1 to process before the main chat handler
async def afk_reply_handler(client, message):
    # Check if the message is a reply to an AFK user
    if message.reply_to_message and message.reply_to_message.from_user.id in AFK_USERS:
        afk_user_id = message.reply_to_message.from_user.id
        user_data = AFK_USERS.get(afk_user_id)
    
    # Check if the message mentions an AFK user
    elif message.entities:
        for entity in message.entities:
            if entity.user and entity.user.id in AFK_USERS:
                afk_user_id = entity.user.id
                user_data = AFK_USERS.get(afk_user_id)
                break
        else:
            return # No AFK user mentioned or replied to

    else:
        return # No mention or reply to check

    if user_data:
        time_afk = get_readable_time(int(time.time() - user_data["time"]))
        reason = user_data["reason"]
        afk_mention = f"[{user_data['first_name']}](tg://user?id={afk_user_id})"
        
        reply_text = f"â— ğ’á´Ê€Ê€Ê, {afk_mention} Éªs ğ€Ò“á´‹!\n" \
                     f"ğŸ•°ï¸ ğ“Éªá´á´‡: {time_afk} á´€É¢á´\n" \
                     f"ğŸ“ ğ‘á´‡á´€sá´É´: {reason}"
        
        await message.reply_text(reply_text, parse_mode=enums.ParseMode.MARKDOWN)

# -------- General Chatbot/AFK Return Handler (FIXED to prevent TypeError) --------

# This filter now correctly handles:

# 1. Is a text message (filters.text)

# 2. Is in a group or supergroup ((filters.group | filters.supergroup))

# 3. Is NOT a command (& ~filters.command)

@app.on_message(filters.text & (filters.group | filters.supergroup) & ~filters.command)

async def general_chat_group(client, message):

Â  Â  # 1. AFK Return Check

Â  Â  user_id = message.from_user.id

Â  Â  if user_id in AFK_USERS:

Â  Â  Â  Â  # User is coming back by sending a message

Â  Â  Â  Â  afk_data = AFK_USERS.pop(user_id)

Â  Â  Â  Â  time_afk = get_readable_time(int(time.time() - afk_data["time"]))

Â  Â  Â  Â  await message.reply_text(

Â  Â  Â  Â  Â  Â  f"ğ–á´‡ÊŸá´„á´á´á´‡ ğá´€á´„á´‹, [{message.from_user.first_name}](tg://user?id={user_id})! ğ˜á´á´œ ğšğ«ğ ğÉ´ÊŸÉªÉ´á´‡ É´á´á´¡. (ğ€Ò“á´‹ Ò“á´Ê€: {time_afk})",

Â  Â  Â  Â  Â  Â  parse_mode=enums.ParseMode.MARKDOWN

Â  Â  Â  Â  )

Â  Â  Â  Â  return



Â  Â  # 2. Chatbot Logic for Groups (Only runs if CHATBOT_STATUS is True)

Â  Â  if not CHATBOT_STATUS.get(message.chat.id, False):

Â  Â  Â  Â  return # Chatbot is disabled for this group



Â  Â  me = await client.get_me()

Â  Â  text = message.text



Â  Â  # Check if the message is a reply to the bot

Â  Â  is_reply_to_bot = message.reply_to_message and message.reply_to_message.from_user.id == me.id

Â  Â Â 

Â  Â  # Check if the message mentions the bot's username

Â  Â  is_mention_bot = me.username.lower() in text.lower() if text and me.username else False

Â  Â Â 

Â  Â  response, is_sticker = get_reply(text)



Â  Â  # Keyword match found (specific or general, but not None)

Â  Â  if response:

Â  Â  Â  Â  # For a specific keyword, reply immediately.

Â  Â  Â  Â  pass

Â  Â  else:

Â  Â  Â  Â  # No specific keyword found, use general chat logic.

Â  Â  Â  Â Â 

Â  Â  Â  Â  # If it's a direct reply/mention, fall back to a generic 'daily' reply if no keyword was matched.

Â  Â  Â  Â  if is_reply_to_bot or is_mention_bot:

Â  Â  Â  Â  Â  Â  response = random.choice(DATA.get("daily", ["Hello ğŸ‘‹"]))

Â  Â  Â  Â  Â  Â  is_sticker = False

Â  Â  Â  Â Â 

Â  Â  Â  Â  # If it's general, non-replied/non-mentioned chat, apply the 80% chance.

Â  Â  Â  Â  elif not is_reply_to_bot and not is_mention_bot and random.random() > 0.20:

Â  Â  Â  Â  Â  Â  Â # 80% chance to reply with a general 'daily' message

Â  Â  Â  Â  Â  Â  response = random.choice(DATA.get("daily", ["Hello ğŸ‘‹"]))

Â  Â  Â  Â  Â  Â  is_sticker = False

Â  Â  Â  Â  else:

Â  Â  Â  Â  Â  Â  # Drop the message (20% chance for non-replied chat)

Â  Â  Â  Â  Â  Â  return

Â  Â Â 

Â  Â  # Send the final response

Â  Â  if response:

Â  Â  Â  Â  if is_sticker:

Â  Â  Â  Â  Â  Â  await message.reply_sticker(response)

Â  Â  Â  Â  else:

Â  Â  Â  Â  Â  Â  await message.reply_text(response)





# -------- General Chatbot Handler for Private Messages (FIXED) --------

# Filter: filters.text & filters.private (always runs in private chats for non-commands)

@app.on_message(filters.text & filters.private & ~filters.command)Â 

async def general_chat_private(client, message):

Â  Â  # 1. AFK Return Check (for consistency)

Â  Â  user_id = message.from_user.id

Â  Â  if user_id in AFK_USERS:

Â  Â  Â  Â  # User is coming back by sending a message

Â  Â  Â  Â  afk_data = AFK_USERS.pop(user_id)

Â  Â  Â  Â  time_afk = get_readable_time(int(time.time() - afk_data["time"]))

Â  Â  Â  Â  await message.reply_text(

Â  Â  Â  Â  Â  Â  f"ğ–á´‡ÊŸá´„á´á´á´‡ ğá´€á´„á´‹, [{message.from_user.first_name}](tg://user?id={user_id})! ğ˜á´á´œ ğšğ«ğ ğÉ´ÊŸÉªÉ´á´‡ É´á´á´¡. (ğ€Ò“á´‹ Ò“á´Ê€: {time_afk})",

Â  Â  Â  Â  Â  Â  parse_mode=enums.ParseMode.MARKDOWN

Â  Â  Â  Â  )

Â  Â  Â  Â  return



Â  Â  # 2. Chatbot Logic for Private Chats (Always runs if not an AFK return)

Â  Â  text = message.text

Â  Â  response, is_sticker = get_reply(text)



Â  Â  # In private chat, always reply, so if no keyword is found, default to 'daily'

Â  Â  if not response:

Â  Â  Â  Â  response = random.choice(DATA.get("daily", ["Hello ğŸ‘‹"]))

Â  Â  Â  Â  is_sticker = False



Â  Â  if response:

Â  Â  Â  Â  if is_sticker:

Â  Â  Â  Â  Â  Â  await message.reply_sticker(response)

Â  Â  Â  Â  else:

Â  Â  Â  Â  Â  Â  await message.reply_text(response)



# [ ... all your final code remains the same ... ]

# ...

if __name__ == "__main__":

Â  Â  print("Starting bot...")

Â  Â  app.run()
